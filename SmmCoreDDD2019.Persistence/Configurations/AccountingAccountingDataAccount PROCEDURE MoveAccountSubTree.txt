
CREATE PROCEDURE [dbo].[MoveAccountSubtree]
	@NoUrutAccountId INT
	, @NewParent INT
	, @Debug BIT = 0
AS
BEGIN
	SET NOCOUNT ON;

	--Disable triggers during operations
	ALTER TABLE Accounting.AccountingDataAccount DISABLE TRIGGER trg_AccountingDataAccount_DEL;
	ALTER TABLE Accounting.AccountingDataAccount DISABLE TRIGGER trg_AccountingDataAccount_INS;
	ALTER TABLE Accounting.AccountingDataAccount DISABLE TRIGGER trg_AccountingDataAccount_UPD;

	--Treat 0/-1/NULL the same: means we want to make the top of this subtree a Root node
	IF (@NewParent <= 0 OR @NewParent IS NULL)
	BEGIN
		SET @NewParent = -1;
	END

	--Cannot move a subtree under itself
	ELSE IF @NewParent IN (
		SELECT SubCat.NoUrutAccountId
		FROM Accounting.AccountingDataAccount Cat
		JOIN Accounting.AccountingDataAccount SubCat
				ON SubCat.Lft BETWEEN Cat.Lft AND Cat.Rgt
		WHERE Cat.NoUrutAccountId = @NoUrutAccountId)
	BEGIN
		RAISERROR (N'Cannot move subtree to a node within itself.', 18, 1);
		RETURN;
	END

	--Cannot move subtree to a node that doesnt exist
	ELSE IF NOT EXISTS (SELECT 1 FROM Accounting.AccountingDataAccount WHERE NoUrutAccountId = @NewParent)
	BEGIN
		RAISERROR (N'Cannot move subtree to a node that doesn''t exist.', 18, 1);
		RETURN;
	END

	--Cannot move subtree that doesnt exist
	ELSE IF NOT EXISTS (SELECT 1 FROM Accounting.AccountingDataAccount WHERE NoUrutAccountId = @NoUrutAccountId)
	BEGIN
		RAISERROR (N'Cannot move subtree that doesn''t exist.', 18, 1);
		RETURN;
	END

	--Get old Parent & Subtree size
	DECLARE @OldParent INT
		, @SubtreeSize INT
		, @SubtreeOldLeft INT
		, @SubtreeOldRight INT
		, @SubtreeOldDepth INT

	SELECT @OldParent = Parent,  @SubtreeSize = Rgt - Lft + 1
		, @SubtreeOldLeft = Lft, @SubtreeOldRight = Rgt, @SubtreeOldDepth = Depth
	FROM Accounting.AccountingDataAccount
	WHERE NoUrutAccountId = @NoUrutAccountId

	--Cannot move subtree to its own Parent, i.e. there's nothing to do b/c new parent is same as old
	IF @OldParent = @NewParent
	BEGIN
		RAISERROR (N'Cannot move subtree to its own parent.', 18, 1);
		RETURN;
	END

	--Get new Parent position
	DECLARE @NewParentRight INT
		, @NewParentDepth INT;

	--If we're going Root, place it to the Right of existing Roots
	IF @NewParent = -1
	BEGIN
		SELECT @NewParentRight = MAX(Rgt) + 1, @NewParentDepth = -1
		FROM Accounting.AccountingDataAccount
	END
	--Else, place it to the Right of its new siblings-to-be
	ELSE
	BEGIN
		SELECT @NewParentRight = Rgt, @NewParentDepth = Depth
		FROM Accounting.AccountingDataAccount 
		WHERE NoUrutAccountId = @NewParent
	END

	--Get new positions for use
	SELECT NoUrutAccountId
		, Lft + @NewParentRight - @SubtreeOldLeft AS PLeft
		, Rgt + @NewParentRight - @SubtreeOldLeft AS PRight
		, Depth + (@NewParentDepth - @SubtreeOldDepth) + 1 AS Depth
	INTO #MoveNodes
	FROM Accounting.AccountingDataAccount
	WHERE NoUrutAccountId IN (
		SELECT SubCat.NoUrutAccountId
		FROM Accounting.AccountingDataAccount Cat
		JOIN Accounting.AccountingDataAccount SubCat
				ON SubCat.Lft BETWEEN Cat.Lft AND Cat.Rgt
		WHERE Cat.NoUrutAccountId = @NoUrutAccountId
	)

	IF (@Debug = 1)
		SELECT * FROM #MoveNodes
		ORDER BY PLeft

	--Make gap in tree (at destination branch) equal to the SubtreeSize
	UPDATE Accounting.AccountingDataAccount
	SET Lft = CASE WHEN Lft > @NewParentRight THEN Lft + @SubtreeSize ELSE Lft END,
		Rgt = CASE WHEN Rgt >= @NewParentRight THEN Rgt + @SubtreeSize ELSE Rgt END
	WHERE Rgt >= @NewParentRight

	--Update Subtree positions to new ones
	UPDATE Accounting.AccountingDataAccount
	SET Lft = #MoveNodes.PLeft, Rgt = #MoveNodes.PRight, Depth = #MoveNodes.Depth
	FROM Accounting.AccountingDataAccount
	JOIN #MoveNodes
			ON Accounting.AccountingDataAccount.NoUrutAccountId = #MoveNodes.NoUrutAccountId

	--Maintain the Adjacency-List part (set ParentID)
	UPDATE Accounting.AccountingDataAccount
	SET Parent = (CASE WHEN @NewParent = -1 THEN NULL ELSE @NewParent END)
	WHERE NoUrutAccountId = @NoUrutAccountId

	--Close gaps, i.e. after the Subtree is gone from its old Parent, said old parent node has no children;
	--while nodes to the right & above now have inflated values, except where they include the newly moved subtree.
	UPDATE Accounting.AccountingDataAccount
	SET Lft = CASE WHEN Lft > @SubtreeOldRight THEN Lft - @SubtreeSize ELSE Lft END,
		Rgt = CASE WHEN Rgt >= @SubtreeOldRight THEN Rgt - @SubtreeSize ELSE Rgt END
	WHERE Rgt >= @SubtreeOldRight

	--Re-enable triggers when done
	ALTER TABLE Accounting.AccountingDataAccount ENABLE TRIGGER trg_AccountingDataAccount_DEL;
	ALTER TABLE Accounting.AccountingDataAccount ENABLE TRIGGER trg_AccountingDataAccount_INS;
	ALTER TABLE Accounting.AccountingDataAccount ENABLE TRIGGER trg_AccountingDataAccount_UPD;
END
GO
